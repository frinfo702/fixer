This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    fixer.mdc
go-server/
  cmd/
    main.go
  delivery/
    helper.go
    http_server.go
  domain/
    model/
      search_test.go
      search.go
  infrastructure/
    rust_search_adapter.go
    searcher_interface.go
  usecase/
    mock/
      searcher_interface_mock.go
    search_interactor_test.go
    search_interactor.go
  go.mod
rust-search/
  src/
    main.rs
  Cargo.toml
test-workspace/
  sample/
    example.txt
.gitignore
docker-compose.yml
Dockerfile
README.md
run.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/fixer.mdc">
---
description: 
globs: 
alwaysApply: true
---

# Your rule content

- You can @ files here
- You can use markdown but dont have to

use `./run.sh` command to build and start server.
</file>

<file path="go-server/delivery/helper.go">
package delivery

const (
	InternalServerErrorMessage = "Internal Server Error"
)
</file>

<file path="go-server/domain/model/search_test.go">
package model

import "testing"

func TestSearchResult(t *testing.T) {
	result := SearchResult{
		FilePath:   "file.go",
		LineNumber: 41,
		LineText:   "Hello, World",
	}
	if result.FilePath != "file.go" || result.LineNumber != 41 || result.LineText != "Hello, World" {
		t.Errorf("SearchResult not assigned properly: %+v", result)
	}
}
</file>

<file path="go-server/domain/model/search.go">
package model

// SearchResultは1件の検索結果を表す
type SearchResult struct {
	FilePath   string
	LineNumber int
	LineText   string
}

// SearchQueryは検索条件を保持
type SearchQuery struct {
	Path  string
	Query string
	Fuzzy bool // Fuzzy means if obvious search is turned on.
}

// Searcherインターフェースは検索機能の抽象化をする
type Searcher interface {
	Search(query SearchQuery) ([]SearchResult, error)
}
</file>

<file path="go-server/infrastructure/searcher_interface.go">
package infrastructure

import "github.com/frinfo702/fixer/domain/model"

type Searcher interface {
	Search(query model.SearchQuery) ([]model.SearchResult, error)
}
</file>

<file path="go-server/usecase/mock/searcher_interface_mock.go">
// Code generated by MockGen. DO NOT EDIT.
// Source: go-server/usecase/searcher_interface.go
//
// Generated by this command:
//
//	mockgen -source=go-server/usecase/searcher_interface.go -destination=go-server/usecase/searcher_interface_mock.go -package=mock
//

// Package mock is a generated GoMock package.
package mock

import (
	reflect "reflect"

	model "github.com/frinfo702/fixer/domain/model"
	gomock "go.uber.org/mock/gomock"
)

// MockSearcher is a mock of Searcher interface.
type MockSearcher struct {
	ctrl     *gomock.Controller
	recorder *MockSearcherMockRecorder
	isgomock struct{}
}

// MockSearcherMockRecorder is the mock recorder for MockSearcher.
type MockSearcherMockRecorder struct {
	mock *MockSearcher
}

// NewMockSearcher creates a new mock instance.
func NewMockSearcher(ctrl *gomock.Controller) *MockSearcher {
	mock := &MockSearcher{ctrl: ctrl}
	mock.recorder = &MockSearcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSearcher) EXPECT() *MockSearcherMockRecorder {
	return m.recorder
}

// Search mocks base method.
func (m *MockSearcher) Search(query model.SearchQuery) ([]model.SearchResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Search", query)
	ret0, _ := ret[0].([]model.SearchResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Search indicates an expected call of Search.
func (mr *MockSearcherMockRecorder) Search(query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Search", reflect.TypeOf((*MockSearcher)(nil).Search), query)
}
</file>

<file path="go-server/usecase/search_interactor_test.go">
package usecase_test

import (
	"errors"
	"reflect"
	"testing"

	"github.com/frinfo702/fixer/domain/model"
	"github.com/frinfo702/fixer/usecase"
	"github.com/frinfo702/fixer/usecase/mock"
	"go.uber.org/mock/gomock"
)

func TestSearchInteractor_Execute_Success(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	// モックの Searcher を生成
	mockSearcher := mock.NewMockSearcher(ctrl)

	query := model.SearchQuery{Path: ".", Query: "test", Fuzzy: false}
	expectedResults := []model.SearchResult{
		{FilePath: "file1.txt", LineNumber: 1, LineText: "this is a test"},
	}

	// Search メソッドが呼ばれることを期待
	mockSearcher.EXPECT().Search(query).Return(expectedResults, nil)

	interactor := usecase.NewSearchInteractor(mockSearcher)
	results, err := interactor.Execute(query)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if !reflect.DeepEqual(results, expectedResults) {
		t.Fatalf("expected %v, got %v", expectedResults, results)
	}
}

func TestSearchInteractor_Execute_Error(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSearcher := mock.NewMockSearcher(ctrl)

	query := model.SearchQuery{Path: ".", Query: "fail", Fuzzy: false}
	expectedErr := errors.New("search failed")
	mockSearcher.EXPECT().Search(query).Return(nil, expectedErr)

	interactor := usecase.NewSearchInteractor(mockSearcher)
	_, err := interactor.Execute(query)
	if err == nil {
		t.Fatal("expected error, got nil")
	}
	if err.Error() != expectedErr.Error() {
		t.Fatalf("expected error %v, got %v", expectedErr, err)
	}
}
</file>

<file path="test-workspace/sample/example.txt">
これはFixerのサンプルファイルです。
検索機能をテストするために使用できます。
以下のキーワードで検索してみてください：
- function
- search
- Rust
- Go
</file>

<file path="go-server/cmd/main.go">
package main

import (
	"log"
	"os"
	"path/filepath"

	"github.com/frinfo702/fixer/delivery"
	"github.com/frinfo702/fixer/infrastructure"
	"github.com/frinfo702/fixer/usecase"
	"github.com/labstack/echo/v4"
)

func main() {
	log.SetOutput(os.Stdout)
	log.SetPrefix("[Fixer] ")
	log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)

	log.Println("Starting Fixer server...")

	binaryPath := os.Getenv("SEARCH_ROOT")
	if binaryPath == "" {
		log.Println("SEARCH_ROOT env variable is empty, so default value was set")
		exePath, _ := os.Executable()
		exeDir := filepath.Dir(exePath)
		binaryPath = filepath.Join(exeDir, "..", "rust-search", "target", "release", "rust_search")
	}

	absPath, err := filepath.Abs(binaryPath)
	if err == nil {
		log.Printf("Absolute path to search binary: %s", absPath)
		_, err := os.Stat(absPath)
		if err != nil {
			log.Printf("Warning: Search binary not found at path: %s, Error: %v", absPath, err)
		} else {
			log.Printf("Search binary exists at path: %s", absPath)
			binaryPath = absPath
		}
	}

	seacher := infrastructure.NewRustSearchAdapter(binaryPath)
	searchInteractor := usecase.NewSearchInteractor(seacher)
	handler := delivery.NewHTTPHandler(searchInteractor)

	e := echo.New()
	handler.RegisterRoutes(e)

	log.Println("Server is ready at http://localhost:8080")
	e.Logger.Fatal(e.Start(":8080"))
}
</file>

<file path="go-server/usecase/search_interactor.go">
package usecase

import (
	"github.com/frinfo702/fixer/domain/model"
	"github.com/frinfo702/fixer/infrastructure"
)

type SearchInteractor struct {
	searcher infrastructure.Searcher
}

func NewSearchInteractor(searcher infrastructure.Searcher) *SearchInteractor {
	return &SearchInteractor{searcher: searcher}
}

// Executeは指定された検索クエリに基づき検索を実行
func (s *SearchInteractor) Execute(query model.SearchQuery) ([]model.SearchResult, error) {
	return s.searcher.Search(query)
}
</file>

<file path="docker-compose.yml">
version: "3.9"
services:
  fixer:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SEARCH_ROOT=/app/fixer
</file>

<file path="run.sh">
#!/bin/bash

echo "Fixer MVPの起動スクリプト"
echo "==============================="

# 現在のディレクトリを基準にパスを設定
PROJECT_ROOT=$(pwd)
RUST_BIN="$PROJECT_ROOT/rust-search/target/release/fixer"
GO_SERVER_DIR="$PROJECT_ROOT/go-server/cmd"
PORT=8080

# プロセスの状態を確認
echo "0. プロセスの状態を確認中..."
PROCESS_EXISTS=false

# 8080ポートを使用しているプロセスを確認
if command -v lsof >/dev/null 2>&1; then
  EXISTING_PID=$(lsof -ti:${PORT} 2>/dev/null)
  if [ ! -z "$EXISTING_PID" ]; then
    PROCESS_EXISTS=true
    echo "ポート ${PORT} で実行中のプロセス ($EXISTING_PID) を終了します"
    kill -9 $EXISTING_PID || true
  fi
fi

# go runプロセスの確認
GO_PID=$(pgrep -f "go run main.go" 2>/dev/null)
if [ ! -z "$GO_PID" ]; then
  PROCESS_EXISTS=true
  echo "go run プロセス ($GO_PID) を終了します"
  pkill -f "go run main.go" || true
fi

# プロセスが存在した場合のみスリープ
if [ "$PROCESS_EXISTS" = true ]; then
  echo "プロセス終了後、1秒待機します..."
  sleep 1
else
  echo "実行中のプロセスはありません。続行します..."
fi

echo "1. Rustバイナリのビルド..."
cd "$PROJECT_ROOT/rust-search"
cargo build --release || { echo "Rustビルドに失敗しました"; exit 1; }

echo "2. Rustバイナリの確認: $RUST_BIN"
if [ ! -f "$RUST_BIN" ]; then
  echo "エラー: Rustバイナリが見つかりません"
  exit 1
fi

# 環境変数ファイルを更新
echo "SEARCH_ROOT=$RUST_BIN" > "$GO_SERVER_DIR/.env"
echo "環境変数ファイルを更新しました: $GO_SERVER_DIR/.env"

echo "3. Goサーバーの起動..."
cd "$GO_SERVER_DIR"
SEARCH_ROOT="$RUST_BIN" go run main.go
</file>

<file path="rust-search/Cargo.toml">
[package]
name = "fixer"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1.0.97"
fuzzy-matcher = "0.3.7"
tantivy = "0.22.0"
tempfile = "3.17.1"
walkdir = "2"
</file>

<file path="Dockerfile">
# Stage 1: Rust 検索エンジンのビルド
FROM rust:1.77 AS builder-rust
WORKDIR /app
COPY rust-search/ ./rust-search/
RUN cd rust-search && cargo build --release

# Stage 2: Go サーバのビルド
FROM golang:1.22-alpine AS builder-go
WORKDIR /app
COPY go-server/ ./go-server/
# builder-rust から Rust バイナリを go-server にコピー
COPY --from=builder-rust /app/rust-search/target/release/fixer ./go-server/fixer
RUN cd go-server && go build -o fixer ./cmd

# Stage 3: 実行用イメージ
FROM debian:stable-slim
WORKDIR /app
COPY --from=builder-go /app/go-server/fixer ./
COPY --from=builder-go /app/go-server/fixer ./
EXPOSE 8080
ENTRYPOINT ["./fixer"]
</file>

<file path="go-server/go.mod">
module github.com/frinfo702/fixer

go 1.22

require (
	github.com/labstack/echo/v4 v4.13.3
	go.uber.org/mock v0.5.0
)

require (
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	golang.org/x/crypto v0.31.0 // indirect
	golang.org/x/net v0.33.0 // indirect
	golang.org/x/sys v0.28.0 // indirect
	golang.org/x/text v0.21.0 // indirect
)
</file>

<file path="README.md">
# Fixer

Fixer is a high-performance, scalable file search engine project that leverages the strengths of both Rust and Go to provide efficient search capabilities.

## 🎯 Project Goals

- Implementation of a high-performance file search engine using Rust
- Provision of a stable HTTP server using Go
- Flexible search functionality through fuzzy matching
- Scalability through microservices architecture

## 🏗 System Architecture

The project consists of two main components:

1. **Rust Search Engine** (`rust-search/`)
   - File system traversal and search index creation
   - Flexible search functionality using fuzzy-matcher
   - High-performance search processing

2. **Go HTTP Server** (`go-server/`)
   - RESTful API provision
   - Integration with Rust search engine
   - Client request handling

## 🚀 Getting Started

### Prerequisites
- Rust 1.70 or higher
- Go 1.20 or higher
- Docker (optional)

### Local Development

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/fixer.git
   cd fixer
   ```

2. Build and Start server
```bash
./run.sh
```

## 🔍 Key Features

- Recursive file system traversal
- Fuzzy matching for filename search
- Full-text search within files
- Search interface through RESTful API

## 🛠 API Endpoints

- `GET /search?q={query}` - Search by filename
- `GET /search/content?q={query}` - Search within file contents
- `GET /status` - Check service status

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request
</file>

<file path="go-server/infrastructure/rust_search_adapter.go">
package infrastructure

import (
	"bytes"
	"fmt"
	"log"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"github.com/frinfo702/fixer/domain/model"
)

// RustSearchAdapterは、Rust 製検索エンジンを呼び出すためのアダプタ
type RustSearchAdapter struct {
	binaryPath string
}

func NewRustSearchAdapter(binaryPath string) *RustSearchAdapter {
	log.Printf("RustSearchAdapter initialized with binary path: %s", binaryPath)
	return &RustSearchAdapter{binaryPath: binaryPath}
}

func (r *RustSearchAdapter) Search(query model.SearchQuery) ([]model.SearchResult, error) {
	// 検索パスを絶対パスに変換
	searchPath := query.Path
	if searchPath != "" && searchPath != "." {
		absPath, err := filepath.Abs(searchPath)
		if err != nil {
			log.Printf("Warning: Failed to convert path to absolute: %v", err)
		} else {
			log.Printf("Converting path '%s' to absolute: '%s'", searchPath, absPath)
			searchPath = absPath
		}
	}

	// 引数リストを構築
	args := []string{query.Query} // 最初にクエリを追加

	// 検索対象ディレクトリを追加 (指定されていれば)
	if searchPath != "" && searchPath != "." {
		args = append(args, "--dir", searchPath)
	}

	// ファジー検索フラグを追加
	if query.Fuzzy {
		args = append(args, "--fuzzy")
	}

	log.Printf("Executing Rust search: %s %v", r.binaryPath, args)
	cmd := exec.Command(r.binaryPath, args...)
	var outBuf, errBuf bytes.Buffer
	cmd.Stdout = &outBuf
	cmd.Stderr = &errBuf
	err := cmd.Run()
	if err != nil {
		errMsg := strings.TrimSpace(errBuf.String())
		if errMsg == "" {
			errMsg = err.Error()
		}
		log.Printf("Rust search error: %s", errMsg)
		return nil, fmt.Errorf("rust search error: %s", errMsg)
	}

	output := outBuf.String()
	log.Printf("Rust search output received: %d bytes", len(output))
	var results []model.SearchResult
	lines := strings.Split(output, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "検索結果") || strings.HasPrefix(line, "スコア:") {
			continue
		}

		// 新しい出力形式に対応
		// 形式: "スコア: XX, ファイルパス:行番号: テキスト"
		if strings.HasPrefix(line, "スコア:") {
			parts := strings.SplitN(line, ",", 2)
			if len(parts) < 2 {
				continue
			}

			// "ファイルパス:行番号: テキスト" の部分を取得
			fileParts := strings.SplitN(strings.TrimSpace(parts[1]), ":", 3)
			if len(fileParts) < 3 {
				continue
			}

			var lineNum int
			fmt.Sscanf(fileParts[1], "%d", &lineNum)
			results = append(results, model.SearchResult{
				FilePath:   fileParts[0],
				LineNumber: lineNum,
				LineText:   strings.TrimSpace(fileParts[2]),
			})
			continue
		}

		// 旧形式のサポートも残す（互換性のため）
		parts := strings.SplitN(line, ":", 3)
		if len(parts) < 3 {
			continue
		}
		var lineNum int
		fmt.Sscanf(parts[1], "%d", &lineNum)
		results = append(results, model.SearchResult{
			FilePath:   parts[0],
			LineNumber: lineNum,
			LineText:   strings.TrimSpace(parts[2]),
		})
	}

	// 検索結果を関連性でソート
	// まず、クエリが行のテキストに含まれるかを確認し、含まれる場合は優先度を高くする
	sort.Slice(results, func(i, j int) bool {
		// クエリが含まれているかをチェック
		queryInI := strings.Contains(strings.ToLower(results[i].LineText), strings.ToLower(query.Query))
		queryInJ := strings.Contains(strings.ToLower(results[j].LineText), strings.ToLower(query.Query))

		// どちらも含まれている場合、文字列の長さが短い方が良い（より具体的なマッチ）
		if queryInI && queryInJ {
			return len(results[i].LineText) < len(results[j].LineText)
		}

		// クエリを含むものを優先
		return queryInI && !queryInJ
	})

	log.Printf("Processed search results: %d items", len(results))
	return results, nil
}
</file>

<file path="go-server/delivery/http_server.go">
package delivery

import (
	"bytes"
	"html/template"
	"net/http"

	"github.com/frinfo702/fixer/domain/model"
	"github.com/frinfo702/fixer/usecase"
	"github.com/labstack/echo/v4"
)

type HTTPHandler struct {
	searchInteractor *usecase.SearchInteractor
	tmpl             *template.Template
}

type PageData struct {
	Query   string
	Path    string
	Fuzzy   bool
	Results []model.SearchResult
	Error   string
}

func NewHTTPHandler(interactor *usecase.SearchInteractor) *HTTPHandler {
	h := &HTTPHandler{searchInteractor: interactor}
	h.tmpl = template.Must(template.New("page").Parse(pageHTML))
	return h
}

func (h *HTTPHandler) RegisterRoutes(e *echo.Echo) {
	e.GET("/", h.handleIndex)
	e.GET("/search", h.handleSearch)
}

func (h *HTTPHandler) handleIndex(c echo.Context) error {
	return c.Redirect(http.StatusTemporaryRedirect, "/search")
}

func (h *HTTPHandler) handleSearch(c echo.Context) error {
	queryStr := c.QueryParam("query")
	fuzzy := c.QueryParam("fuzzy") == "on"
	// パスパラメータを取得する（デフォルト値は "."）
	targetDir := c.QueryParam("path")
	if targetDir == "" {
		targetDir = "."
	}

	data := PageData{
		Query: queryStr,
		Path:  targetDir,
		Fuzzy: fuzzy,
	}

	if queryStr != "" {
		searchQuery := model.SearchQuery{
			Path:  targetDir,
			Query: queryStr,
			Fuzzy: fuzzy,
		}
		results, err := h.searchInteractor.Execute(searchQuery)
		if err != nil {
			data.Error = err.Error()
		} else {
			// 結果を最大10個に制限
			if len(results) > 10 {
				data.Results = results[:10]
			} else {
				data.Results = results
			}
		}
	}

	// テンプレートをバッファにレンダリングして、HTMLレスポンスとして返す
	var buf bytes.Buffer
	if err := h.tmpl.Execute(&buf, data); err != nil {
		return c.String(http.StatusInternalServerError, InternalServerErrorMessage)
	}

	return c.HTML(http.StatusOK, buf.String())
}

const pageHTML = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixer - Code Search</title>
    <style>
        :root {
            /* Google-inspired color palette */
            --blue-primary: #4285F4;
            --blue-hover: #1a73e8;
            --red: #EA4335;
            --yellow: #FBBC05;
            --green: #34A853;
            --gray-50: #F8F9FA;
            --gray-100: #F1F3F4;
            --gray-200: #E8EAED;
            --gray-300: #DADCE0;
            --gray-400: #BDC1C6;
            --gray-500: #9AA0A6;
            --gray-600: #80868B;
            --gray-700: #5F6368;
            --gray-800: #3C4043;
            --gray-900: #202124;
            --shadow-sm: 0 1px 2px rgba(60, 64, 67, 0.1);
            --shadow-md: 0 2px 6px rgba(60, 64, 67, 0.15);
            --shadow-lg: 0 4px 12px rgba(60, 64, 67, 0.2);
            --font-family: 'Google Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            --mono-font: 'Google Sans Mono', 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--gray-50);
            color: var(--gray-900);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem 0;
            text-align: center;
        }

        .logo {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .logo-text {
            font-size: 2rem;
            font-weight: 500;
            color: var(--gray-900);
            letter-spacing: -0.02em;
        }

        .logo-text span:nth-child(1) { color: var(--blue-primary); }
        .logo-text span:nth-child(2) { color: var(--red); }
        .logo-text span:nth-child(3) { color: var(--yellow); }
        .logo-text span:nth-child(4) { color: var(--blue-primary); }
        .logo-text span:nth-child(5) { color: var(--green); }
        .logo-text span:nth-child(6) { color: var(--red); }
        .logo-text span:nth-child(7) { color: var(--blue-primary); }
        .logo-text span:nth-child(8) { color: var(--green); }
        .logo-text span:nth-child(9) { color: var(--yellow); }
        .logo-text span:nth-child(10) { color: var(--blue-primary); }

        .tagline {
            font-size: 0.95rem;
            color: var(--gray-600);
            margin-bottom: 2rem;
        }

        .search-container {
            width: 100%;
            max-width: 650px;
            margin: 0 auto 2rem;
        }

        .search-box {
            position: relative;
            margin-bottom: 1.5rem;
        }

        .search-input {
            width: 100%;
            padding: 0.85rem 1rem 0.85rem 3rem;
            font-size: 1rem;
            border: 1px solid var(--gray-300);
            border-radius: 24px;
            background-color: white;
            color: var(--gray-900);
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        .search-input:focus {
            outline: none;
            box-shadow: var(--shadow-md);
            border-color: var(--blue-primary);
        }

        .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--gray-600);
            width: 20px;
            height: 20px;
        }

        .input-group {
            margin-bottom: 1rem;
        }
        
        .input-label {
            display: block;
            font-size: 0.9rem;
            color: var(--gray-700);
            margin-bottom: 0.5rem;
        }
        
        .path-input {
            width: 100%;
            padding: 0.75rem 1rem;
            font-size: 0.95rem;
            border: 1px solid var(--gray-300);
            border-radius: 8px;
            background-color: white;
            color: var(--gray-900);
            transition: all 0.2s ease;
        }
        
        .path-input:focus {
            outline: none;
            border-color: var(--blue-primary);
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
        }
        
        .dir-button {
            background-color: var(--gray-100);
            color: var(--gray-800);
            border: 1px solid var(--gray-300);
            padding: 0.5rem 0.75rem;
            font-size: 0.9rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 0.5rem;
        }
        
        .dir-button:hover {
            background-color: var(--gray-200);
        }
        
        .dir-help {
            font-size: 0.8rem;
            color: var(--gray-600);
            margin-top: 0.25rem;
        }

        .search-options {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--gray-400);
            border-radius: 2px;
            margin-right: 8px;
            position: relative;
            cursor: pointer;
            background-color: white;
            transition: all 0.2s ease;
        }

        input[type="checkbox"]:checked {
            background-color: var(--blue-primary);
            border-color: var(--blue-primary);
        }

        input[type="checkbox"]:checked::after {
            content: "";
            position: absolute;
            left: 5px;
            top: 1px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        input[type="checkbox"]:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
        }

        .checkbox-label {
            font-size: 0.875rem;
            color: var(--gray-700);
        }

        .search-button {
            background-color: var(--blue-primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 0.95rem;
            font-weight: 500;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-button:hover {
            background-color: var(--blue-hover);
            box-shadow: var(--shadow-sm);
        }

        .search-button:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.3);
        }

        .keyboard-hint {
            display: inline-flex;
            align-items: center;
            font-size: 0.75rem;
            color: var(--gray-500);
        }

        kbd {
            background-color: var(--gray-100);
            border: 1px solid var(--gray-300);
            border-radius: 3px;
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
            font-size: 0.7rem;
            font-family: inherit;
            padding: 0.1rem 0.3rem;
            margin: 0 0.1rem;
        }

        .results-container {
            margin-top: 2rem;
        }

        .results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--gray-200);
        }

        .results-count {
            font-size: 0.95rem;
            color: var(--gray-700);
        }

        .results-count strong {
            color: var(--blue-primary);
        }

        .result {
            background-color: white;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border-left: 3px solid var(--blue-primary);
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        .result:hover {
            box-shadow: var(--shadow-md);
        }

        .file {
            font-family: var(--mono-font);
            font-weight: 500;
            color: var(--gray-800);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
        }

        .file-icon {
            color: var(--gray-600);
            margin-right: 0.5rem;
        }

        .line-number {
            color: white;
            background-color: var(--blue-primary);
            font-family: var(--mono-font);
            font-size: 0.75rem;
            padding: 0.125rem 0.375rem;
            border-radius: 12px;
            margin-left: 0.5rem;
        }

        .line-text {
            display: block;
            margin-top: 0.5rem;
            font-family: var(--mono-font);
            font-size: 0.9rem;
            line-height: 1.5;
            padding: 0.75rem;
            background-color: var(--gray-50);
            border-radius: 4px;
            overflow-x: auto;
            color: var(--gray-800);
            border: 1px solid var(--gray-200);
        }

        .error {
            background-color: rgba(234, 67, 53, 0.1);
            color: var(--red);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
        }

        .error-icon {
            margin-right: 0.5rem;
        }

        .no-results {
            text-align: center;
            padding: 3rem 0;
            color: var(--gray-600);
        }

        .no-results-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: var(--gray-400);
        }

        .empty-state {
            text-align: center;
            padding: 4rem 0;
        }

        .empty-state-icon {
            font-size: 3.5rem;
            color: var(--blue-primary);
            margin-bottom: 1.5rem;
        }

        .empty-state-text {
            color: var(--gray-700);
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
        }

        .features-list {
            text-align: left;
            max-width: 450px;
            margin: 0 auto;
            color: var(--gray-600);
            background-color: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
        }

        .features-list li {
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
        }

        .features-list li:last-child {
            margin-bottom: 0;
        }

        .feature-icon {
            color: var(--blue-primary);
            margin-right: 0.75rem;
            flex-shrink: 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .search-options {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
            }

            .keyboard-hint {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <h1 class="logo-text">
                    <span>R</span><span>u</span><span>s</span><span>t</span><span>y</span><span>S</span><span>e</span><span>a</span><span>r</span><span>c</span><span>h</span>
                </h1>
            </div>
            <p class="tagline">Fast and fuzzy code search powered by Rust and Go</p>
        </header>

        <div class="search-container">
            <form method="GET" action="/search">
                <div class="search-box">
                    <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                    <input 
                        type="text" 
                        id="query" 
                        name="query" 
                        value="{{.Query}}" 
                        placeholder="Search code..." 
                        class="search-input" 
                        autocomplete="off"
                    />
                </div>
                
                <div class="input-group">
                    <label for="path" class="input-label">検索対象ディレクトリ（絶対パスまたは相対パス）:</label>
                    <input 
                        type="text" 
                        id="path" 
                        name="path" 
                        value="{{.Path}}" 
                        placeholder="/path/to/search" 
                        class="path-input"
                    />
                    <p class="dir-help">例: /Users/username/projects/myapp（絶対パス）または ./src（相対パス）</p>
                </div>
                
                <div class="search-options">
                    <label class="checkbox-container">
                        <input type="checkbox" name="fuzzy" id="fuzzy" {{if .Fuzzy}}checked{{end}} />
                        <span class="checkbox-label">Enable fuzzy search</span>
                    </label>
                    
                    <div class="keyboard-hint">
                        <span>Shortcut: <kbd>Ctrl</kbd> + <kbd>K</kbd> for query</span>
                    </div>
                    
                    <button type="submit" class="search-button">Search</button>
                </div>
            </form>
        </div>

        {{if .Error}}
            <div class="error">
                <svg class="error-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                <span>{{.Error}}</span>
            </div>
        {{end}}

        {{if .Results}}
            <div class="results-container">
                <div class="results-header">
                    <div class="results-count">
                        <strong>{{len .Results}}</strong> results found
                    </div>
                </div>
                
                {{range .Results}}
                    <div class="result">
                        <div class="file">
                            <svg class="file-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14 2 14 8 20 8"></polyline>
                            </svg>
                            {{.FilePath}}
                            <span class="line-number">{{.LineNumber}}</span>
                        </div>
                        <code class="line-text">{{.LineText}}</code>
                    </div>
                {{end}}
            </div>
        {{else if and (not .Error) (ne .Query "")}}
            <div class="no-results">
                <div class="no-results-icon">🔍</div>
                <p>No matches found for "<strong>{{.Query}}</strong>"</p>
                <p>Try adjusting your search query or enable fuzzy search for more flexible matching.</p>
            </div>
        {{else if and (not .Error) (eq .Query "")}}
            <div class="empty-state">
                <div class="empty-state-icon">🚀</div>
                <p class="empty-state-text">Powerful code search at your fingertips</p>
                <ul class="features-list">
                    <li>
                        <svg class="feature-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9 11 12 14 22 4"></polyline>
                            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
                        </svg>
                        Search for functions, variables, or specific code patterns
                    </li>
                    <li>
                        <svg class="feature-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9 11 12 14 22 4"></polyline>
                            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
                        </svg>
                        Enable fuzzy search for more flexible matching
                    </li>
                    <li>
                        <svg class="feature-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9 11 12 14 22 4"></polyline>
                            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
                        </svg>
                        Results show file location and exact line numbers
                    </li>
                    <li>
                        <svg class="feature-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9 11 12 14 22 4"></polyline>
                            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
                        </svg>
                        Powered by Rust for lightning-fast performance
                    </li>
                </ul>
            </div>
        {{end}}
    </div>

    <script>
        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl+K to focus query input
            if (e.key === 'k' && (e.ctrlKey || e.metaKey) && document.activeElement.tagName !== 'INPUT') {
                e.preventDefault();
                document.getElementById('query').focus();
            }
        });
    </script>
</body>
</html>
`
</file>

<file path=".gitignore">
.env

# Rust関連
/rust-search/target/
**/*.rs.bk
Cargo.lock
/rust-search/.DS_Store

# Go関連
/go-server/bin/
/go-server/pkg/
/go-server/vendor/
/go-server/.DS_Store
/go-server/.env


# macOS関連
.DS_Store
.AppleDouble
.LSOverride
._*

# ユーザー設定
$HOME/.fixer/
test-workspace/.fixer

# ビルド成果物
**/debug/
**/release/

# ログファイル
*.log
/logs/

# エディタ・IDE
.idea/
.vscode/
*.swp
*.swo
*~

# その他
.env.local
.env.development.local
.env.test.local
.env.production.local
</file>

<file path="rust-search/src/main.rs">
use anyhow::Result;
use std::{env, fs, path::Path};
use walkdir::WalkDir;

fn main() -> Result<()> {
    let args: Vec<String> = env::args().collect();

    let mut query = None;
    let mut target_dir = "."; // デフォルトはカレントディレクトリ
    let mut fuzzy_mode = false;
    let mut arg_index = 1;
    while arg_index < args.len() {
        match args[arg_index].as_str() {
            "--dir" | "-d" => {
                arg_index += 1;
                if arg_index < args.len() {
                    target_dir = args[arg_index].as_str();
                } else {
                    eprintln!("エラー: --dir オプションにはディレクトリパスが必要です。");
                    std::process::exit(1);
                }
            }
            "--fuzzy" | "-f" => {
                fuzzy_mode = true;
            }
            _ => {
                if query.is_none() {
                    query = Some(&args[arg_index]);
                } else {
                    eprintln!(
                        "エラー: 不明な引数または複数のクエリが指定されました: {}",
                        args[arg_index]
                    );
                    print_usage(&args[0]);
                    std::process::exit(1);
                }
            }
        }
        arg_index += 1;
    }

    if query.is_none() {
        print_usage(&args[0]);
        std::process::exit(1);
    }
    let query = query.unwrap();

    println!(
        "検索結果 (ディレクトリ: {}, クエリ: {}, Fuzzy: {}):",
        target_dir, query, fuzzy_mode
    );
    search_in_directory(target_dir, query, fuzzy_mode)?;

    Ok(())
}

fn print_usage(program_name: &str) {
    println!(
        "使用法: {} <検索クエリ> [-d <ディレクトリ>] [-f | --fuzzy]",
        program_name
    );
    println!("  <検索クエリ>: 検索する文字列");
    println!(
        "  -d, --dir <ディレクトリ>: 検索対象のディレクトリ (デフォルト: カレントディレクトリ)"
    );
    println!("  -f, --fuzzy: ファジー検索を有効にする");
}

fn search_in_directory(dir: &str, query: &str, fuzzy_mode: bool) -> Result<()> {
    for entry in WalkDir::new(dir)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file())
    {
        let path = entry.path();

        // バイナリファイルや特定の拡張子ファイルを除外
        if should_skip_file(path) {
            continue;
        }

        match fs::read_to_string(path) {
            Ok(content) => {
                search_in_content(path, &content, query, fuzzy_mode)?;
            }
            Err(_) => {
                // ファイルの読み込みに失敗した場合は無視して続行
                continue;
            }
        }
    }

    Ok(())
}

fn should_skip_file(path: &Path) -> bool {
    // バイナリファイル、巨大ファイル、特定の拡張子を持つファイルを除外
    let extension = path.extension().and_then(|e| e.to_str()).unwrap_or("");
    let skip_extensions = ["exe", "dll", "so", "dylib", "bin", "obj", "o", "a", "lib"];

    // node_modules や .git ディレクトリ内のファイルを除外
    let path_str = path.to_str().unwrap_or("");
    if path_str.contains("node_modules") || path_str.contains(".git") {
        return true;
    }

    skip_extensions.contains(&extension)
}

fn search_in_content(path: &Path, content: &str, query: &str, fuzzy_mode: bool) -> Result<()> {
    let path_str = path.to_str().unwrap_or("unknown_path");
    let query_lower = query.to_lowercase();

    if fuzzy_mode {
        // fuzzy-matcherを使用したファジー検索（今回はMVPなので実装しない）
        // fuzzy_search_in_content(path_str, content, &query_lower)?;
    } else {
        // 単純なサブストリング検索
        for (line_number, line) in content.lines().enumerate() {
            let line_lower = line.to_lowercase();
            if line_lower.contains(&query_lower) {
                println!("{}:{}:{}", path_str, line_number + 1, line);
            }
        }
    }

    Ok(())
}
</file>

</files>
